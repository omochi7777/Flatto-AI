This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
api/chat.js
index.html
README.md
script.js
styles.css
修正指示
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="修正指示">
Codex への修正依頼

## 目的

GitHub Pages は **デモ専用（APIは叩かない）**にする。

本番は Vercel の /api/chat 経由で OpenAI を呼ぶ。

ブラウザでユーザーに API キーを入力させる UI は既定では非表示（BYOK は任意で有効化可能）。

## 変更対象

index.html

script.js

新規：/api/chat.js（Vercel Serverless Function）

任意：README.md（導線の追記）

## やりたいこと（実装要件）

# 1. index.html の冒頭に デモ判定＋Pagesガードを追加

?demo=1 のときのみデモを有効化し、API呼び出しをブロック（fetch のラップで /api と openai.com を拒否）。

*.github.io では デモ以外を停止して、案内文を表示。

# 2. script.js の OpenAI“直呼び”を禁止し、sendChat() を /api/chat POST に変更。

デモ時は mockChat() を返す。

# 3. 新規 api/chat.js を追加し、サーバ側で process.env.OPENAI_API_KEY を使用して OpenAI を呼ぶ。

未設定時は 500 とメッセージを返す。

# 4.（任意）GET /api/chat で { ok:true, hasKey:boolean } を返すヘルスチェック。

（任意）キー入力UIがある場合は 既定で非表示に変更し、?byok=1 の時だけ表示されるよう切替。



## 制約・方針

クライアントにキーを露出しない（NEXT_PUBLIC_ 変数は使わない）。

既存の UI/UX を壊さない（チャット送信の関数名や戻り値の形は維持）。

既存コードへの変更は 最小差分で。

## 受け入れ基準（動作確認）

✅ https://…github.io/…/?demo=1 で UI が動き、ネットワークタブに /api や openai.com が出ない。

✅ https://…github.io/…/（?demo=1 なし）は ブロック案内が出る。

✅ https://<app>.vercel.app で OPENAI_API_KEY を設定済みなら、キー入力なしで会話できる。

✅ GET /api/chat が { ok:true, hasKey:true } を返す（任意）。

✅ BYOK（?byok=1）にするとキー入力UIが出る（任意）。

## 変更差分（雛形）

1) index.html（冒頭へ追記）

<script>
(() => {
  const u = new URL(location.href);
  const DEMO = u.searchParams.get('demo') === '1';
  const isPages = /\.github\.io$/.test(location.hostname) || location.hostname === 'github.io';
  window.__DEMO__ = DEMO;

  if (DEMO) {
    const _fetch = window.fetch.bind(window);
    window.fetch = (input, init) => {
      const s = String(input);
      if (s.includes('/api') || s.includes('openai.com')) {
        return Promise.reject(new Error('Demo mode blocks API calls'));
      }
      return _fetch(input, init);
    };
    document.documentElement.classList.add('demo');
  }

  if (isPages && !DEMO) {
    addEventListener('DOMContentLoaded', () => {
      document.body.innerHTML =
        '<h2>🚫 GitHub Pages はデモ専用</h2><p><code>?demo=1</code> を付けてUIのみ試せます。本番はVercelへ。</p>';
    });
    throw new Error('Blocked on GitHub Pages (non-demo)');
  }
})();
</script>


2) script.js（直呼び→/api 経由＋デモ時モック）

 async function sendChat(messages){
-  const r = await fetch('https://api.openai.com/v1/chat/completions', {
-    method: 'POST',
-    headers: {
-      'Content-Type': 'application/json',
-      Authorization: `Bearer ${state.config.apiKey}`,
-    },
-    body: JSON.stringify(requestBody),
-  });
+  if (window.__DEMO__) return mockChat(messages);
+  const r = await fetch('/api/chat', {
+    method: 'POST',
+    headers: { 'Content-Type': 'application/json' },
+    body: JSON.stringify({ messages }),
+  });
   return r.json();
 }

+async function mockChat(messages){
+  const last = messages?.at(-1)?.content ?? '';
+  return { choices: [{ message:{ role:'assistant',
+    content: `これはデモ応答です 👋\n入力:「${last.slice(0,60)}」\n本番はVercelでデプロイしてね。` } }] };
+}


3) 新規 api/chat.js

export default async function handler(req, res){
  if (req.method === 'GET') {
    return res.status(200).json({ ok: true, hasKey: Boolean(process.env.OPENAI_API_KEY) });
  }
  if (req.method !== 'POST') return res.status(405).end();

  const key = process.env.OPENAI_API_KEY;
  if (!key) return res.status(500).json({ error: 'OPENAI_API_KEY is not set' });

  const { messages, model = 'gpt-4o-mini' } = req.body || {};
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method:'POST',
    headers:{ 'Content-Type':'application/json', Authorization:`Bearer ${key}` },
    body: JSON.stringify({ model, messages })
  });
  res.status(r.status).json(await r.json());
}
</file>

<file path=".gitignore">
# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Temporary files
*.tmp
*.temp

# Build outputs
dist/
build/
</file>

<file path="api/chat.js">
export default async function handler(req, res) {
  if (req.method === 'GET') {
    return res.status(200).json({ ok: true, hasKey: Boolean(process.env.OPENAI_API_KEY) });
  }
  if (req.method !== 'POST') return res.status(405).end();

  const key = process.env.OPENAI_API_KEY;
  if (!key) return res.status(500).json({ error: 'OPENAI_API_KEY is not set' });

  const { messages, model = 'gpt-4o-mini' } = req.body || {};
  const r = await fetch('https://api.openai.com/v1/chat/completions', {
    method:'POST',
    headers:{ 'Content-Type':'application/json', Authorization:`Bearer ${key}` },
    body: JSON.stringify({ model, messages })
  });
  res.status(r.status).json(await r.json());
}
</file>

<file path="styles.css">
:root {
  color-scheme: light;
  --app-background: linear-gradient(160deg, #f0fbff 0%, #ffffff 60%, #f9efff 100%);
  --surface: rgba(255, 255, 255, 0.82);
  --surface-strong: rgba(255, 255, 255, 0.94);
  --border-soft: rgba(100, 120, 140, 0.15);
  --shadow-soft: 0 18px 40px -24px rgba(58, 72, 94, 0.4);
  --text-primary: #193046;
  --text-secondary: rgba(25, 48, 70, 0.64);
  --accent: #1fb6ff;
  --accent-strong: #0076ff;
  --assistant-bubble: #ffffff;
  --assistant-border: rgba(31, 182, 255, 0.22);
  --user-bubble: linear-gradient(135deg, #45e6b8 0%, #1ec7ff 100%);
  --user-text: #043752;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

html,
body {
  margin: 0;
  padding: 0;
  height: 100%;
}

body {
  font-family: "Noto Sans JP", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--app-background);
  color: var(--text-primary);
  display: flex;
  justify-content: center;
}

.app {
  position: relative;
  display: grid;
  grid-template-rows: auto 1fr auto;
  width: min(100%, 480px);
  height: 100dvh;
  padding: clamp(16px, 4vw, 24px);
  gap: 16px;
}

.topbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  background: var(--surface);
  border: 1px solid var(--border-soft);
  border-radius: 18px;
  box-shadow: var(--shadow-soft);
  backdrop-filter: blur(16px);
  position: sticky;
  top: clamp(16px, 4vw, 24px);
  z-index: 10;
}

.layer {
  position: absolute;
  inset: 0;
  display: flex;
  visibility: hidden;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.28s ease;
  z-index: 15;
}

.layer.is-open {
  visibility: visible;
  opacity: 1;
  pointer-events: auto;
}

.drawer-layer {
  justify-content: flex-start;
  align-items: stretch;
}

.settings-layer {
  justify-content: center;
  align-items: center;
}

.backdrop {
  position: absolute;
  inset: 0;
  background: rgba(18, 38, 58, 0.16);
  backdrop-filter: blur(2px);
  transition: opacity 0.28s ease;
}

.drawer-backdrop {
  background: linear-gradient(120deg, rgba(10, 30, 46, 0.18), rgba(18, 82, 110, 0.06));
}

.settings-backdrop {
  background: rgba(8, 25, 38, 0.22);
}

.layer:not(.is-open) .backdrop {
  opacity: 0;
}

.layer.is-open .backdrop {
  opacity: 1;
}

.chat-drawer {
  position: relative;
  width: min(360px, 82vw);
  background: var(--surface);
  border: 1px solid var(--border-soft);
  border-radius: 22px;
  box-shadow: 0 28px 64px -36px rgba(20, 60, 90, 0.45);
  padding: 20px 18px;
  margin: clamp(16px, 5vw, 28px) 0;
  display: grid;
  grid-template-rows: auto auto 1fr;
  gap: 18px;
  transform: translateX(-120%);
  transition: transform 0.32s cubic-bezier(0.16, 1, 0.3, 1);
  backdrop-filter: blur(20px);
}

.drawer-layer.is-open .chat-drawer {
  transform: translateX(0);
}

.drawer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.drawer-header h2 {
  margin: 0;
  font-size: 1.12rem;
  font-weight: 700;
}

.drawer-close {
  width: 38px;
  height: 38px;
  background: rgba(255, 255, 255, 0.6);
}

.drawer-actions {
  display: flex;
  justify-content: flex-start;
}

.new-thread-button {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border: 1px solid rgba(31, 182, 255, 0.24);
  background: rgba(255, 255, 255, 0.7);
  color: var(--accent-strong);
  font-weight: 600;
  border-radius: 999px;
  padding: 8px 14px;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.new-thread-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 8px 18px -14px rgba(31, 182, 255, 0.8);
}

.new-thread-button svg {
  width: 18px;
  height: 18px;
  stroke: currentColor;
  stroke-width: 1.8;
  fill: none;
}

.drawer-content {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.thread-list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.thread-list-entry {
  display: flex;
  align-items: stretch;
  gap: 10px;
}

.thread-item {
  width: 100%;
  flex: 1 1 auto;
  border: 1px solid rgba(25, 48, 70, 0.08);
  border-radius: 16px;
  padding: 12px 14px;
  background: rgba(255, 255, 255, 0.82);
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 6px;
  cursor: pointer;
  box-shadow: 0 16px 34px -30px rgba(25, 48, 70, 0.8);
  transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
}

.thread-item:hover {
  transform: translateX(2px);
  box-shadow: 0 22px 38px -28px rgba(25, 48, 70, 0.7);
}

.thread-item.is-active {
  border-color: rgba(31, 182, 255, 0.4);
  box-shadow: 0 24px 46px -28px rgba(31, 182, 255, 0.6);
  background: rgba(255, 255, 255, 0.92);
}

.thread-item-delete {
  align-self: center;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: none;
  background: rgba(255, 255, 255, 0.86);
  box-shadow: inset 0 0 0 1px rgba(31, 182, 255, 0.1);
  color: var(--accent);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: transform 0.14s ease, box-shadow 0.14s ease;
}

.thread-item-delete svg {
  width: 18px;
  height: 18px;
  stroke: currentColor;
  stroke-width: 2;
  fill: none;
}

.thread-item-delete:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 26px -20px rgba(31, 182, 255, 0.5), inset 0 0 0 1px rgba(31, 182, 255, 0.15);
}

.thread-item-delete:focus-visible {
  outline: 2px solid rgba(31, 182, 255, 0.68);
  outline-offset: 2px;
}

.thread-item-delete:active {
  transform: translateY(0);
  box-shadow: inset 0 0 0 1px rgba(31, 182, 255, 0.22);
}

.thread-item-delete[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
  box-shadow: inset 0 0 0 1px rgba(31, 182, 255, 0.05);
}

[data-theme="midnight"] .thread-item-delete {
  background: rgba(27, 40, 58, 0.82);
  color: var(--accent-strong);
  box-shadow: inset 0 0 0 1px rgba(31, 182, 255, 0.18);
}

.thread-title {
  font-weight: 700;
  color: var(--text-primary);
  max-width: 100%;
  text-align: left;
}

.thread-preview {
  font-size: 0.82rem;
  color: var(--text-secondary);
  text-align: left;
  max-width: 100%;
}

.thread-empty {
  margin: 0;
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.settings-modal {
  position: relative;
  width: min(520px, 92vw);
  max-height: min(640px, 92vh);
  background: var(--surface-strong);
  border: 1px solid rgba(25, 48, 70, 0.12);
  border-radius: 24px;
  box-shadow: 0 36px 90px -40px rgba(12, 42, 68, 0.55);
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  transform: scale(0.96);
  transition: transform 0.28s cubic-bezier(0.16, 1, 0.3, 1);
  backdrop-filter: blur(22px);
}

.settings-layer.is-open .settings-modal {
  transform: scale(1);
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
}

.settings-header h2 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: 700;
}

.settings-header p {
  margin: 4px 0 0;
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.settings-form {
  display: flex;
  flex-direction: column;
  gap: 24px;
  overflow-y: auto;
  padding-right: 4px;
}

.settings-section {
  border: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.settings-section legend {
  font-weight: 700;
  margin-bottom: 6px;
  color: var(--text-primary);
}

.field {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.field-label {
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--text-secondary);
}

.field input,
.field textarea,
.field select {
  font: inherit;
  color: var(--text-primary);
  border-radius: 12px;
  border: 1px solid rgba(25, 48, 70, 0.15);
  background: rgba(255, 255, 255, 0.9);
  padding: 10px 12px;
  box-shadow: inset 0 1px 2px rgba(25, 48, 70, 0.05);
}

.field select {
  appearance: none;
  background-image: radial-gradient(circle at right 0.75rem center, rgba(31, 182, 255, 0.35) 0, rgba(31, 182, 255, 0.35) 45%, transparent 46%);
  background-repeat: no-repeat;
  background-size: 0.75rem 0.75rem;
  background-position: right 0.85rem center;
  padding-right: 2.4rem;
}

.field textarea {
  resize: vertical;
  min-height: 96px;
}

.field-support {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.field-support [data-avatar-status] {
  display: block;
  margin-top: 4px;
}

.field-actions {
  display: flex;
  gap: 12px;
  margin-top: 6px;
  justify-content: flex-start;
  align-items: center;
}

.text-button {
  border: none;
  padding: 0;
  background: none;
  color: var(--accent-strong);
  font: inherit;
  font-size: 0.82rem;
  cursor: pointer;
}

.text-button:hover {
  text-decoration: underline;
}

.text-button:disabled {
  opacity: 0.5;
  cursor: default;
}

.settings-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  padding-top: 8px;
}

.primary-button,
.ghost-button {
  font: inherit;
  font-weight: 700;
  border-radius: 999px;
  padding: 10px 18px;
  cursor: pointer;
  transition: transform 0.16s ease, box-shadow 0.16s ease;
}

.primary-button {
  border: none;
  color: #ffffff;
  background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
  box-shadow: 0 14px 32px -22px rgba(0, 118, 255, 0.9);
}

.primary-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 20px 42px -24px rgba(0, 118, 255, 0.85);
}

.ghost-button {
  border: 1px solid rgba(25, 48, 70, 0.16);
  color: var(--text-secondary);
  background: rgba(255, 255, 255, 0.7);
}

.ghost-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 16px 36px -28px rgba(25, 48, 70, 0.35);
}
.icon-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.6);
  box-shadow: inset 0 0 0 1px rgba(31, 182, 255, 0.08);
  color: var(--accent);
}

.icon-button svg {
  width: 22px;
  height: 22px;
  stroke: currentColor;
  stroke-width: 1.8;
  fill: none;
}

.icon-button[disabled] {
  opacity: 0.6;
  cursor: not-allowed;
  box-shadow: inset 0 0 0 1px rgba(31, 182, 255, 0.04);
}

.profile {
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 1 1 auto;
  min-width: 0;
}

.avatar {
  position: relative;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(145deg, #80e8ff, #30b7ff);
  color: #ffffff;
  display: grid;
  place-items: center;
  font-weight: 700;
  letter-spacing: 0.08em;
  box-shadow: 0 6px 18px -10px rgba(0, 136, 255, 0.6);
  overflow: hidden;
}

.avatar-image {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.avatar-initial {
  font-size: 1.125rem;
  z-index: 1;
  transition: opacity 0.2s ease;
}

.avatar[data-has-image="true"] .avatar-initial {
  opacity: 0;
}

.identity {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.identity .name {
  font-size: 1.05rem;
  font-weight: 700;
}

.identity .status {
  font-size: 0.82rem;
  color: var(--text-secondary);
}

.chat-thread {
  position: relative;
  background: var(--surface-strong);
  border-radius: 22px;
  border: 1px solid var(--border-soft);
  padding: 18px 16px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: var(--shadow-soft);
  backdrop-filter: blur(20px);
}

.chat-thread::before {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(120% 65% at 50% 0%, rgba(31, 182, 255, 0.12) 0%, transparent 65%);
  pointer-events: none;
}

.chat-messages {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 12px;
  flex: 1 1 auto;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: rgba(31, 182, 255, 0.3) transparent;
}

.chat-messages::-webkit-scrollbar {
  width: 6px;
}

.chat-messages::-webkit-scrollbar-thumb {
  border-radius: 999px;
  background: rgba(31, 182, 255, 0.3);
}

.chat-empty {
  text-align: center;
  color: var(--text-secondary);
  font-size: 0.92rem;
  padding: 24px 12px;
}

.chat-message {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-width: 96%;
}

.chat-message.is-typing .chat-meta {
  color: var(--accent-strong);
}

.chat-message.is-typing .chat-meta::after {
  content: '...';
  display: inline-block;
  overflow: hidden;
  white-space: nowrap;
  width: 0;
  animation: meta-dots 1.2s steps(4, end) infinite;
}

.chat-message.is-typing .chat-bubble::after {
  content: '';
  position: absolute;
  right: 14px;
  bottom: 10px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: rgba(31, 182, 255, 0.45);
  box-shadow: 0 0 0 0 rgba(31, 182, 255, 0.25);
  animation: bubble-pulse 1.4s ease-out infinite;
}

.chat-message[data-role="user"] {
  align-self: flex-end;
  text-align: right;
}

.chat-message[data-role="assistant"] {
  align-self: flex-start;
}

.chat-bubble {
  position: relative;
  padding: 14px 16px;
  border-radius: 18px 18px 4px 18px;
  line-height: 1.55;
  font-size: 0.96rem;
  white-space: pre-wrap;
  word-break: break-word;
}

.chat-message[data-role="assistant"] .chat-bubble {
  background: var(--assistant-bubble);
  border: 1px solid var(--assistant-border);
  border-radius: 18px 18px 18px 6px;
  box-shadow: 0 18px 26px -22px rgba(31, 182, 255, 0.5);
}

.chat-message[data-role="user"] .chat-bubble {
  background: var(--user-bubble);
  color: var(--user-text);
  font-weight: 600;
  border-radius: 18px 6px 18px 18px;
  box-shadow: 0 18px 24px -20px rgba(31, 182, 255, 0.65);
}

.chat-meta {
  font-size: 0.75rem;
  color: var(--text-secondary);
}

.composer {
  display: grid;
  grid-template-columns: 1fr auto;
  align-items: flex-end;
  gap: 12px;
  padding: 12px 16px;
  background: var(--surface);
  border: 1px solid var(--border-soft);
  border-radius: 22px;
  box-shadow: var(--shadow-soft);
  backdrop-filter: blur(16px);
  position: sticky;
  bottom: clamp(16px, 4vw, 24px);
}

.composer textarea {
  resize: none;
  width: 100%;
  font: inherit;
  line-height: 1.6;
  border: none;
  padding: 10px 0;
  background: transparent;
  color: var(--text-primary);
}

.composer textarea::placeholder {
  color: rgba(25, 48, 70, 0.4);
}

.composer textarea:focus {
  outline: none;
}

.send-button {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  border: none;
  border-radius: 999px;
  padding: 10px 16px;
  font-weight: 700;
  font-size: 0.95rem;
  color: #ffffff;
  background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
  box-shadow: 0 12px 28px -18px rgba(0, 118, 255, 0.9);
  cursor: pointer;
}

.send-button svg {
  width: 18px;
  height: 18px;
  stroke: none;
  fill: currentColor;
}

.send-button:disabled {
  opacity: 0.5;
  cursor: default;
}

.chat-message.is-typing .chat-bubble {
  padding-right: 32px;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

@media (max-width: 480px) {
  .app {
    padding: 16px;
  }

  .topbar {
    border-radius: 16px;
  }

  .chat-thread {
    border-radius: 18px;
    padding: 16px 14px;
  }

  .composer {
    border-radius: 18px;
    padding: 12px 14px;
  }
}

@media (min-width: 640px) {
  .app {
    border-radius: 28px;
    max-height: 860px;
    align-self: center;
    box-shadow: 0 30px 80px -48px rgba(40, 90, 120, 0.45);
  }

  body {
    align-items: center;
  }
}

@keyframes meta-dots {
  0% {
    width: 0;
  }
  33% {
    width: 0.5em;
  }
  66% {
    width: 1em;
  }
  100% {
    width: 1.5em;
  }
}

@keyframes bubble-pulse {
  0% {
    transform: scale(1);
    opacity: 0.9;
  }
  70% {
    transform: scale(1.4);
    opacity: 0.2;
  }
  100% {
    transform: scale(1);
    opacity: 0.9;
  }
}
.byok-feature {
  display: none;
}

html.byok .byok-feature {
  display: block;
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>FreshChat UI</title>
    <script>
      (() => {
        const u = new URL(location.href);
        const DEMO = u.searchParams.get('demo') === '1';
        const BYOK = u.searchParams.get('byok') === '1';
        const isPages = /\.github\.io$/.test(location.hostname) || location.hostname === 'github.io';
        window.__DEMO__ = DEMO;
        window.__BYOK__ = BYOK;

        if (DEMO) {
          const _fetch = window.fetch.bind(window);
          window.fetch = (input, init) => {
            const s = String(input);
            if (s.includes('/api') || s.includes('openai.com')) {
              console.warn('Demo mode blocks API calls to:', s);
              return Promise.reject(new Error('Demo mode blocks API calls'));
            }
            return _fetch(input, init);
          };
          document.documentElement.classList.add('demo');
        }

        if(BYOK){
          document.documentElement.classList.add('byok');
        }

        if (isPages && !DEMO) {
          addEventListener('DOMContentLoaded', () => {
            document.body.innerHTML =
              '<h2>🚫 GitHub Pages はデモ専用</h2><p><code>?demo=1</code> を付けてUIのみ試せます。本番はVercelへ。</p>';
          });
          throw new Error('Blocked on GitHub Pages (non-demo)');
        }
      })();
    </script>
    <link rel="stylesheet" href="styles.css">
    <script defer src="script.js"></script>
  </head>
  <body>
    <main class="app" data-theme="daybreak" data-chat-open="false" data-settings-open="false">
      <header class="topbar" role="banner">
        <button
          class="icon-button drawer-toggle"
          type="button"
          aria-label="&#x30B9;&#x30EC;&#x30C3;&#x30C9;&#x4E00;&#x89A7;&#x3092;&#x958B;&#x304F;"
          aria-expanded="false"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M4 6h16M4 12h12M4 18h16" vector-effect="non-scaling-stroke" />
          </svg>
        </button>
        <div class="profile">
          <div class="avatar" aria-hidden="true">
            <img class="avatar-image" alt="" decoding="async" hidden />
            <span class="avatar-initial">A</span>
          </div>
          <div class="identity">
            <span class="name">Aeris</span>
            <span class="status">&#x3044;&#x3064;&#x3067;&#x3082;&#x76F8;&#x8AC7;&#x3067;&#x304D;&#x307E;&#x3059;</span>
          </div>
        </div>
        <button
          class="icon-button settings-toggle"
          type="button"
          aria-label="&#x8A2D;&#x5B9A;&#x30E2;&#x30FC;&#x30C0;&#x30EB;&#x3092;&#x958B;&#x304F;"
          aria-haspopup="dialog"
          aria-expanded="false"
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path
              d="M11.22 2.25c-.28-.83-1.44-.83-1.72 0l-.56 1.56a1 1 0 0 1-1.47.55l-1.35-.78c-.76-.44-1.6.41-1.16 1.16l.78 1.35a1 1 0 0 1-.55 1.47l-1.56.56c-.83.28-.83 1.44 0 1.72l1.56.56a1 1 0 0 1 .55 1.47l-.78 1.35c-.44.76.4 1.6 1.16 1.16l1.35-.78a1 1 0 0 1 1.47.55l.56 1.56c.28.83 1.44.83 1.72 0l.56-1.56a1 1 0 0 1 1.47-.55l1.35.78c.76.44 1.6-.4 1.16-1.16l-.78-1.35a1 1 0 0 1 .55-1.47l1.56-.56c.83-.28.83-1.44 0-1.72l-1.56-.56a1 1 0 0 1-.55-1.47l.78-1.35c.44-.76-.4-1.6-1.16-1.16l-1.35.78a1 1 0 0 1-1.47-.55l-.56-1.56Z"
              vector-effect="non-scaling-stroke"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
            <path
              d="M9.75 12a2.25 2.25 0 1 0 4.5 0 2.25 2.25 0 0 0-4.5 0Z"
              vector-effect="non-scaling-stroke"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </button>
      </header>

      <div class="layer drawer-layer" data-role="drawer-layer">
        <div class="backdrop drawer-backdrop" data-action="close-drawer" aria-hidden="true"></div>
        <aside
          class="chat-drawer"
          aria-labelledby="drawer-title"
          aria-hidden="true"
          tabindex="-1"
        >
          <header class="drawer-header">
            <h2 id="drawer-title">&#x30C1;&#x30E3;&#x30C3;&#x30C8;&#x30B9;&#x30EC;&#x30C3;&#x30C9;</h2>
            <button class="drawer-close icon-button" type="button" data-action="close-drawer" aria-label="&#x30B9;&#x30EC;&#x30C3;&#x30C9;&#x4E00;&#x89A7;&#x3092;&#x9589;&#x3058;&#x308B;">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M6 6 18 18M6 18 18 6" vector-effect="non-scaling-stroke" />
              </svg>
            </button>
          </header>
          <div class="drawer-actions">
            <button class="new-thread-button" type="button" data-action="create-thread">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M12 5v14M5 12h14" vector-effect="non-scaling-stroke" />
              </svg>
              <span>&#x65B0;&#x898F;&#x30B9;&#x30EC;&#x30C3;&#x30C9;</span>
            </button>
          </div>
          <nav class="drawer-content" aria-label="&#x65E2;&#x5B58;&#x30B9;&#x30EC;&#x30C3;&#x30C9;&#x4E00;&#x89A7;">
            <ol class="thread-list" role="list"></ol>
            <p class="thread-empty" hidden>&#x307E;&#x3060;&#x30B9;&#x30EC;&#x30C3;&#x30C9;&#x304C;&#x3042;&#x308A;&#x307E;&#x305B;&#x3093;&#x3002;&#x65B0;&#x898F;&#x30B9;&#x30EC;&#x30C3;&#x30C9;&#x3092;&#x4F5C;&#x6210;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;&#x3002;</p>
          </nav>
        </aside>
      </div>

      <div class="layer settings-layer" data-role="settings-layer">
        <div class="backdrop settings-backdrop" data-action="close-settings" aria-hidden="true"></div>
        <section
          class="settings-modal"
          role="dialog"
          aria-modal="true"
          aria-labelledby="settings-title"
          aria-describedby="settings-description"
          aria-hidden="true"
          tabindex="-1"
        >
          <header class="settings-header">
            <div>
              <h2 id="settings-title">&#x8A2D;&#x5B9A;</h2>
              <p id="settings-description">&#x30C1;&#x30E3;&#x30C3;&#x30C8;&#x306E;&#x52D5;&#x4F5C;&#x3068;&#x30A2;&#x30B7;&#x30B9;&#x30BF;&#x30F3;&#x30C8;&#x306E;&#x60C5;&#x5831;&#x3092;&#x8ABF;&#x6574;&#x3057;&#x307E;&#x3059;&#x3002;</p>
            </div>
            <button class="settings-close icon-button" type="button" data-action="close-settings" aria-label="&#x8A2D;&#x5B9A;&#x3092;&#x9589;&#x3058;&#x308B;">
              <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <path d="M6 6 18 18M6 18 18 6" vector-effect="non-scaling-stroke" />
              </svg>
            </button>
          </header>
          <form class="settings-form" autocomplete="off">
            <fieldset class="settings-section">
              <legend>&#x30A2;&#x30B7;&#x30B9;&#x30BF;&#x30F3;&#x30C8;&#x60C5;&#x5831;</legend>
              <label class="field">
                <span class="field-label">&#x8868;&#x793A;&#x540D;</span>
                <input type="text" name="assistantName" placeholder="Aeris" value="Aeris" />
              </label>
              <label class="field">
                <span class="field-label">&#x30B9;&#x30C6;&#x30FC;&#x30BF;&#x30B9;&#x30C6;&#x30AD;&#x30B9;&#x30C8;</span>
                <input type="text" name="assistantStatus" placeholder="&#x3044;&#x3064;&#x3067;&#x3082;&#x76F8;&#x8AC7;&#x3067;&#x304D;&#x307E;&#x3059;" value="&#x3044;&#x3064;&#x3067;&#x3082;&#x76F8;&#x8AC7;&#x3067;&#x304D;&#x307E;&#x3059;" />
              </label>
              <label class="field">
                <span class="field-label">&#x30ED;&#x30FC;&#x30AB;&#x30EB;&#x753B;&#x50CF;&#x30A2;&#x30C3;&#x30D7;&#x30ED;&#x30FC;&#x30C9;</span>
                <input type="file" name="avatarFile" accept="image/*" />
                <small class="field-support">
                  &#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x306F;1MB&#x4EE5;&#x4E0B;&#x306E;PNG/JPEG/SVG&#x3092;&#x4F7F;&#x7528;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;&#x3002;
                  <span data-avatar-status>&#x30A2;&#x30C3;&#x30D7;&#x30ED;&#x30FC;&#x30C9;&#x753B;&#x50CF;&#x306F;&#x307E;&#x3060;&#x3042;&#x308A;&#x307E;&#x305B;&#x3093;&#x3002;</span>
                </small>
                <div class="field-actions">
                  <button type="button" class="text-button" data-action="clear-avatar">&#x30A2;&#x30C3;&#x30D7;&#x30ED;&#x30FC;&#x30C9;&#x3092;&#x30AF;&#x30EA;&#x30A2;</button>
                </div>
              </label>
            </fieldset>
            <fieldset class="settings-section">
              <legend>OpenAI &#x63A5;&#x7D9A;</legend>
              <label class="field byok-feature">
                <span class="field-label">API &#x30AD;&#x30FC;</span>
                <input
                  type="password"
                  name="apiKey"
                  placeholder="sk-..."
                  autocomplete="off"
                />
                <small class="field-support">&#x30D6;&#x30E9;&#x30A6;&#x30B6;&#x306E;&#x30ED;&#x30FC;&#x30AB;&#x30EB;&#x30B9;&#x30C8;&#x30EC;&#x30FC;&#x30B8;&#x306B;&#x306E;&#x307F;&#x4FDD;&#x5B58;&#x3055;&#x308C;&#x307E;&#x3059;&#x3002;</small>
              </label>
              <label class="field">
                <span class="field-label">&#x30E2;&#x30C7;&#x30EB;</span>
                <select name="model">
                  <option value="gpt-4o-latest" selected>GPT-4o Latest</option>
                  <option value="gpt-4o-mini">GPT-4o mini</option>
                  <option value="gpt-4.1">GPT-4.1</option>
                </select>
                <small class="field-support">&#x5B9F;&#x969B;&#x306B;&#x547C;&#x3073;&#x51FA;&#x3059;OpenAI&#x30E2;&#x30C7;&#x30EB;&#x3092;&#x9078;&#x629E;&#x3057;&#x307E;&#x3059;&#x3002;</small>
              </label>
              <label class="field">
                <span class="field-label">&#x30B7;&#x30B9;&#x30C6;&#x30E0;&#x30D7;&#x30ED;&#x30F3;&#x30D7;&#x30C8;</span>
                <textarea
                  name="systemPrompt"
                  rows="3"
                  placeholder="&#x30A2;&#x30B7;&#x30B9;&#x30BF;&#x30F3;&#x30C8;&#x306B;&#x6C42;&#x3081;&#x308B;&#x30C8;&#x30FC;&#x30F3;&#x3084;&#x30EB;&#x30FC;&#x30EB;"
                >&#x3042;&#x306A;&#x305F;&#x306F;UI&#x8A2D;&#x8A08;&#x3092;&#x624B;&#x4F1D;&#x3046;&#x89AA;&#x3057;&#x307F;&#x3084;&#x3059;&#x3044;&#x30A2;&#x30B7;&#x30B9;&#x30BF;&#x30F3;&#x30C8;&#x3067;&#x3059;&#x3002;&#x5E38;&#x306B;&#x65E5;&#x672C;&#x8A9E;&#x3067;&#x3001;&#x660E;&#x308B;&#x304F;&#x524D;&#x5411;&#x304D;&#x306A;&#x53E3;&#x8ABF;&#x3067;&#x4E01;&#x5BE7;&#x306B;&#x56DE;&#x7B54;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;&#x3002;</textarea>
              </label>
            </fieldset>
            <div class="settings-actions">
              <button type="button" class="ghost-button" data-action="close-settings">&#x30AD;&#x30E3;&#x30F3;&#x30BB;&#x30EB;</button>
              <button type="submit" class="primary-button">&#x4FDD;&#x5B58;</button>
            </div>
          </form>
        </section>
      </div>

      <section class="chat-thread" aria-label="&#x30C1;&#x30E3;&#x30C3;&#x30C8;&#x30B9;&#x30EC;&#x30C3;&#x30C9;">
        <div class="chat-empty" role="status">&#x30E1;&#x30C3;&#x30BB;&#x30FC;&#x30B8;&#x3092;&#x9001;&#x4FE1;&#x3057;&#x3066;&#x4F1A;&#x8A71;&#x3092;&#x59CB;&#x3081;&#x307E;&#x3057;&#x3087;&#x3046;&#x3002;</div>
        <ol class="chat-messages" aria-live="polite"></ol>
      </section>

      <form class="composer" autocomplete="off">
        <label class="sr-only" for="message-input">&#x30E1;&#x30C3;&#x30BB;&#x30FC;&#x30B8;&#x672C;&#x6587;</label>
        <textarea
          id="message-input"
          name="message"
          rows="1"
          placeholder="&#x805E;&#x304D;&#x305F;&#x3044;&#x3053;&#x3068;&#x3092;&#x66F8;&#x3044;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;&#x2026;"
          maxlength="2000"
          required
        ></textarea>
        <button class="send-button" type="submit" disabled>
          <span>&#x9001;&#x4FE1;</span>
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M4.3 4.3 20 12 4.3 19.7l1.4-5.6 8.3-2.1-8.3-2.1z" vector-effect="non-scaling-stroke" />
          </svg>
        </button>
      </form>
    </main>
  </body>
</html>
</file>

<file path="README.md">
# ふらっとAI - スマホ用チャットアプリ

スマートフォン向けチャットUIアプリケーションです。（PCからでももちろん操作可能）
Open AIのAPIを使用する前提のUIです。（API利用には利用料金がかかりますので注意してください）
APIをさくっと使ってみたい方におすすめです！改変などご自由にどうぞ！

## 特徴

- 📱 **レスポンシブデザイン**: スマートフォン画面（320-428px）に最適化
- 🎨 **シンプルなUI**: 使いやすくてシンプルなデザインを目指しました
- 💬 **リアルタイムチャット**: OpenAI APIとの連携でリアルタイム会話
- ⚙️ **カスタマイズ可能**: アシスタント名、アバター、システムプロンプトを設定可能
- 🔒 **ローカル保存**: ブラウザのローカルストレージでデータを安全に保存

## ファイル構成

```
├── index.html          # メインHTMLファイル
├── styles.css          # スタイルシート
├── script.js           # JavaScript機能
└── README.md           # このファイル
```

## 使用方法

## ✅ はじめに（必要なもの）
- いずれかの方法でデプロイします。**最短は「A. ワンクリック」**です。
  - A. ワンクリック：**GitHubアカウント** + **Vercelアカウント**（無料プランで使用できます）
  - B. GitHubなし：Vercelアカウント + PC + Vercel CLI
  - C. デモ：APIなしのモックでUIだけ試す

> セキュリティ上の理由で **GitHub Pages では動作させないでください**。  
> OpenAIのAPIキーが公開されます。必ず Vercel でデプロイし、キーは**環境変数**に設定してください。

---

## 🚀 はじめ方（Vercel ダッシュボードから）
[![Open Vercel Dashboard](https://img.shields.io/badge/Open%20Vercel%20Dashboard-000?logo=vercel)](https://vercel.com/dashboard)

1. ダッシュボードを開く（未登録なら表示に従って無料登録）
2. 右上 **Add New… → Project**
3. **GitHub** を接続し、このリポジトリを選んで **Import**
4. （必要なら）**Root Directory** を指定
5. **Environment Variables** に `OPENAI_API_KEY` を追加
6. **Deploy** を押す

セキュリティ上、**GitHub Pages では本番運用不可**です。  
UIだけ試すデモは `?demo=1`、本番は必ず Vercel を使ってください。
---

## GitHubアカウントなしでデプロイする場合（Vercel CLI）
1. 右上 **Code → Download ZIP** でコード取得（GitHubアカウント不要）  
2. PCで解凍し、フォルダで以下を実行：

```bash
npm i -g vercel
vercel login
vercel env add OPENAI_API_KEY   # OpenAIのAPIキーを入力
vercel --prod

## デプロイ後の手順

1. デプロイしたURL（PCの場合は`index.html`）をブラウザで開く
2. 設定ボタン（⚙️）をクリックしてOpenAI APIキーを設定
3. メッセージを入力してAIと会話できます

## 設定項目

- **アシスタント名**: AIアシスタントの表示名
- **ステータステキスト**: アシスタントの状態表示
- **APIキー**: OpenAI APIキー（必須）
- **モデル**: 使用するOpenAIモデル（GPT-4o Latest推奨）
- **システムプロンプト**: AIアシスタントの性格や役割を定義
- **アバター画像**: アシスタントのアイコン画像

## 技術仕様

- **フロントエンド**: HTML5, CSS3, Vanilla JavaScript
- **API連携**: OpenAI Chat Completions API
- **データ保存**: localStorage
- **対応ブラウザ**: Safari iOS16+, Chrome Android, Chromium Desktop

## ライセンス

このプロジェクトはMITライセンスの下で公開されています。


---

**注意**: OpenAI APIキーは安全に管理し、他人と共有しないでください。
</file>

<file path="script.js">
(() => {
  'use strict';

  const STORAGE_KEY = 'freshchat-thread';
  const CONFIG_KEY = 'freshchat-config';
  const DEFAULT_SYSTEM_PROMPT =
    '\u3042\u306A\u305F\u306FUI\u8A2D\u8A08\u3092\u624B\u4F1D\u3046\u89AA\u3057\u307F\u3084\u3059\u3044\u30A2\u30B7\u30B9\u30BF\u30F3\u30C8\u3067\u3059\u3002\u5E38\u306B\u65E5\u672C\u8A9E\u3067\u3001\u660E\u308B\u304F\u524D\u5411\u304D\u306A\u53E3\u8ABF\u3067\u4E01\u5BE7\u306B\u56DE\u7B54\u3057\u3066\u304F\u3060\u3055\u3044\u3002';
  const SUPPORTED_MODELS = ['gpt-4o-latest', 'gpt-4o-mini', 'gpt-4.1'];
  const MAX_AVATAR_FILE_SIZE = 1024 * 1024; // 1MB
  const MAX_AVATAR_DIMENSION = 256;
  const MIN_AVATAR_DIMENSION = 48;
  const MAX_AVATAR_DATA_LENGTH = 140000; // ~280KB as UTF-16, keeps storage under control
  const MAIN_THREAD_TITLE = '\u30E1\u30A4\u30F3\u30B9\u30EC\u30C3\u30C9';
  const NEW_THREAD_TITLE_BASE = '\u30B9\u30EC\u30C3\u30C9';
  const THREAD_STORAGE_VERSION = 2;
  const AVATAR_STATUS_TEXT = {
    inUse: '\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u6E08\u307F\u306E\u753B\u50CF\u3092\u4F7F\u7528\u3057\u3066\u3044\u307E\u3059\u3002',
    processing: '\u753B\u50CF\u3092\u51E6\u7406\u4E2D\u3067\u3059\u2026',
    usingUrl: '\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u753B\u50CF\u306F\u3042\u308A\u307E\u305B\u3093\uFF08URL\u3092\u5229\u7528\u4E2D\uFF09\u3002',
    empty: '\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u753B\u50CF\u306F\u3042\u308A\u307E\u305B\u3093\u3002',
    chooseImage: '\u753B\u50CF\u30D5\u30A1\u30A4\u30EB\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
    sizeLimit: '\u753B\u50CF\u306F1MB\u4EE5\u4E0B\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002',
    readError: '\u753B\u50CF\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F\u3002',
    pending: '\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u753B\u50CF\u304C\u4FDD\u5B58\u5F85\u3061\u3067\u3059\u3002',
    cleared: '\u30A2\u30C3\u30D7\u30ED\u30FC\u30C9\u753B\u50CF\u3092\u30AF\u30EA\u30A2\u3057\u307E\u3057\u305F\u3002\u4FDD\u5B58\u3059\u308B\u3068\u53CD\u6620\u3055\u308C\u307E\u3059\u3002',
  };
  const DEFAULT_CONFIG = {
    assistantName: 'Aeris',
    assistantStatus: '\u3044\u3064\u3067\u3082\u76F8\u8AC7\u3067\u304D\u307E\u3059',
    apiKey: '',
    systemPrompt: DEFAULT_SYSTEM_PROMPT,
    model: 'gpt-4o-latest',
    avatarUrl: '',
    avatarData: '',
  };

  const app = document.querySelector('.app');
  if (!app) return;

  const threadEl = app.querySelector('.chat-messages');
  const emptyStateEl = app.querySelector('.chat-empty');
  const formEl = app.querySelector('.composer');
  const textareaEl = formEl.querySelector('textarea');
  const sendButtonEl = formEl.querySelector('.send-button');
  const composerDefaultPlaceholder = textareaEl.getAttribute('placeholder') || '';
  const composerNoThreadPlaceholder = '\u307E\u305A\u65B0\u3057\u3044\u30B9\u30EC\u30C3\u30C9\u3092\u4F5C\u6210\u3057\u3066\u304F\u3060\u3055\u3044\u3002';
  const profileNameEl = app.querySelector('.identity .name');
  const profileStatusEl = app.querySelector('.identity .status');
  const avatarEl = app.querySelector('.avatar');
  const avatarImageEl = avatarEl?.querySelector('.avatar-image');
  const avatarInitialEl = avatarEl?.querySelector('.avatar-initial');

  const drawerToggle = app.querySelector('.drawer-toggle');
  const drawerLayer = app.querySelector('[data-role="drawer-layer"]');
  const drawerBackdrop = drawerLayer?.querySelector('[data-action="close-drawer"]');
  const drawerEl = drawerLayer?.querySelector('.chat-drawer');
  const drawerClose = drawerLayer?.querySelector('.drawer-close');
  const newThreadButton = drawerLayer?.querySelector('[data-action="create-thread"]');
  const threadListEl = drawerLayer?.querySelector('.thread-list');
  const threadEmptyEl = drawerLayer?.querySelector('.thread-empty');

  const settingsToggle = app.querySelector('.settings-toggle');
  const settingsLayer = app.querySelector('[data-role="settings-layer"]');
  const settingsBackdrop = settingsLayer?.querySelector('[data-action="close-settings"]');
  const settingsModal = settingsLayer?.querySelector('.settings-modal');
  const settingsCloseButtons = settingsLayer?.querySelectorAll('[data-action="close-settings"]') || [];
  const settingsForm = settingsLayer?.querySelector('.settings-form');
  const avatarFileInput = settingsForm?.elements.namedItem('avatarFile');
  const avatarStatusEl = settingsForm?.querySelector('[data-avatar-status]');
  const avatarClearButton = settingsForm?.querySelector('[data-action="clear-avatar"]');

  const assistantProfile = {
    name: DEFAULT_CONFIG.assistantName,
    cannedReplies: [
      '\u4E86\u89E3\u3057\u307E\u3057\u305F\u3002\u6B21\u306B\u9032\u3081\u305F\u3044\u5185\u5BB9\u304C\u3042\u308C\u3070\u6559\u3048\u3066\u304F\u3060\u3055\u3044\u3002',
      '\u30C1\u30E3\u30C3\u30C8\u6B04\u306E\u30D9\u30FC\u30B9\u306F\u6574\u3044\u307E\u3057\u305F\u3002\u7D9A\u3044\u3066\u30B9\u30EC\u30C3\u30C9\u4E00\u89A7\u3092\u6574\u3048\u307E\u3057\u3087\u3046\u304B\uFF1F',
      '\u6C17\u306B\u306A\u308B\u8981\u4EF6\u304C\u3042\u308C\u3070\u3001\u3044\u3064\u3067\u3082\u6C17\u8EFD\u306B\u805E\u3044\u3066\u304F\u3060\u3055\u3044\u306D\u3002',
      '\u3044\u3044\u611F\u3058\u3067\u3059\u306D\uFF01\u3053\u306E\u307E\u307E\u660E\u308B\u3044\u30C8\u30FC\u30F3\u3067\u78E8\u304D\u8FBC\u3093\u3067\u3044\u304D\u307E\u3057\u3087\u3046\u3002',
    ],
  };

  const state = {
    threads: [],
    activeThreadId: null,
    messages: [],
    messageElements: new Map(),
    pendingAssistant: null,
    config: loadConfig(),
    focusTrapHandlers: {
      drawer: null,
      settings: null,
    },
    lastFocused: {
      drawer: null,
      settings: null,
    },
    draftAvatarData: '',
    avatarReadToken: 0,
  };

  assistantProfile.name = state.config.assistantName || DEFAULT_CONFIG.assistantName;
  state.draftAvatarData = state.config.avatarData || '';

  function init() {
    const { threads, activeThreadId } = loadThreadState();
    state.threads = threads;
    state.activeThreadId = activeThreadId;
    state.messages = getActiveThreadMessages();
    renderAllMessages();
    updateEmptyState();
    renderThreadList();
    applyConfigToUI();
    autoResizeTextArea();
    updateSendButton();

    textareaEl.addEventListener('input', () => {
      autoResizeTextArea();
      updateSendButton();
    });

    formEl.addEventListener('submit', handleSubmit);
    window.addEventListener('beforeunload', saveMessages);
    document.addEventListener('keydown', handleGlobalKeydown);

    if (drawerToggle) {
      drawerToggle.addEventListener('click', () => {
        if (app.dataset.chatOpen === 'true') {
          closeDrawer();
        } else {
          openDrawer();
        }
      });
    }

    drawerBackdrop?.addEventListener('click', closeDrawer);
    drawerClose?.addEventListener('click', closeDrawer);
    newThreadButton?.addEventListener('click', handleCreateThread);

    threadListEl?.addEventListener('click', (event) => {
      const deleteTarget = event.target.closest('[data-action="delete-thread"]');
      if (deleteTarget) {
        event.preventDefault();
        const threadId = deleteTarget.dataset.threadId;
        if (threadId) {
          handleDeleteThread(threadId);
        }
        return;
      }
      const button = event.target.closest('.thread-item');
      if (!button) return;
      const threadId = button.dataset.threadId;
      if (threadId) {
        setActiveThread(threadId, { scrollBehavior: 'auto' });
        if (!textareaEl.disabled) {
          textareaEl.focus();
        }
      }
      closeDrawer();
    });

    if (settingsToggle) {
      settingsToggle.addEventListener('click', () => {
        if (app.dataset.settingsOpen === 'true') {
          closeSettings();
        } else {
          openSettings();
        }
      });
    }

    settingsBackdrop?.addEventListener('click', closeSettings);
    settingsCloseButtons.forEach((button) => button.addEventListener('click', closeSettings));
    settingsForm?.addEventListener('submit', handleSettingsSubmit);
    if (avatarFileInput instanceof HTMLInputElement) {
      avatarFileInput.addEventListener('change', handleAvatarFileChange);
    }
    avatarClearButton?.addEventListener('click', clearAvatarSelection);

    applyDefaultAvatarStatus();
    exposeFreshchatApi();
  }

  function handleSubmit(event) {
    event.preventDefault();
    if (!getActiveThread()) return;
    const content = textareaEl.value.trim();
    if (!content) return;

    cancelPendingAssistant();

    const userMessage = createMessage('user', content);
    appendMessage(userMessage);

    textareaEl.value = '';
    autoResizeTextArea();
    updateSendButton();
    if (!textareaEl.disabled) {
      textareaEl.focus();
    }

    requestAssistantReply(content);
  }

  function playFallbackAnimation(messageId, finalText) {
    const entry = state.messageElements.get(messageId);
    if (!entry) {
      finalizeMessage(messageId, finalText);
      return;
    }
    runTypewriterAnimation(entry.bubble, finalText, () => {
      finalizeMessage(messageId, finalText);
    });
  }

  async function sendChat(messages, signal) {
    if (window.__DEMO__) {
      return mockChat(messages);
    }

    const modelId = SUPPORTED_MODELS.includes(state.config.model)
      ? state.config.model
      : DEFAULT_CONFIG.model;

    const body = {
      messages,
      model: modelId,
      systemPrompt: (state.config.systemPrompt || DEFAULT_SYSTEM_PROMPT).trim() || DEFAULT_SYSTEM_PROMPT,
    };

    if (window.__BYOK__) {
      body.apiKey = state.config.apiKey;
    }

    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      signal,
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API error: ${response.status} ${errorText}`);
    }
    return response.json();
  }

  async function mockChat(messages) {
    const last = messages?.at(-1)?.content ?? '';
    await new Promise(r => setTimeout(r, 800));
    return {
      choices: [
        {
          message: {
            role: 'assistant',
            content: `これはデモ応答です 👋\n入力:「${last.slice(
              0,
              60
            )}」\n本番はVercelでデプロイしてね。`,
          },
        },
      ],
    };
  }

  function requestAssistantReply(userContent) {
    const assistantMessage = createMessage('assistant', '');
    appendMessage(assistantMessage, { persist: false });
    setTypingState(assistantMessage.id, true);
    setMessageStatus(assistantMessage.id, `${assistantProfile.name}・生成中`);

    const tracker = {
      messageId: assistantMessage.id,
      controller: new AbortController(),
      threadId: state.activeThreadId,
    };
    state.pendingAssistant = tracker;

    const pastMessages = getActiveThreadMessages()
      .filter((message) => message.id !== tracker.messageId && message.content.trim().length > 0)
      .map((message) => ({
        role: message.role,
        content: message.content,
      }));

    if (!window.__DEMO__ && !window.__BYOK__ && !state.config.apiKey) {
       const fallback = pickAssistantReply(userContent);
       playFallbackAnimation(tracker.messageId, fallback);
       state.pendingAssistant = null;
       return;
    }

    (async () => {
      const signal = tracker.controller.signal;
      try {
        const data = await sendChat(pastMessages, signal);
        const content = data.choices?.[0]?.message?.content;
        if (content) {
          playFallbackAnimation(tracker.messageId, content);
        } else {
          throw new Error('No content in response');
        }
      } catch (error) {
        if (signal.aborted) {
          const partial = '（応答は中断されました）';
          finalizeMessage(tracker.messageId, partial);
          return;
        }
        console.error('Assistant request failed:', error);
        const failure =
          'すみません、応答の取得に失敗しました。時間をおいてから再試行してください。';
        finalizeMessage(tracker.messageId, failure);
      } finally {
        state.pendingAssistant = null;
      }
    })();
  }

  function cancelPendingAssistant() {
    if (!state.pendingAssistant) return;
    state.pendingAssistant.controller.abort();
    state.pendingAssistant = null;
  }

  function createMessage(role, content) {
    return {
      id: generateMessageId(),
      role,
      content,
      createdAt: Date.now(),
    };
  }

  function appendMessage(message, options = {}) {
    const { persist = true, scrollBehavior = 'smooth' } = options;
    const thread = getActiveThread();
    if (!thread) return;
    thread.messages.push(message);
    thread.updatedAt = Date.now();
    state.messages = thread.messages;
    if (persist) {
      saveMessages();
    }
    const { element, bubble, meta } = buildMessageElement(message);
    state.messageElements.set(message.id, { element, bubble, meta });
    threadEl.appendChild(element);
    updateEmptyState();
    renderThreadList();
    scrollToBottom(scrollBehavior);
  }

  function buildMessageElement(message) {
    const element = document.createElement('li');
    element.className = 'chat-message';
    element.dataset.role = message.role;

    const bubble = document.createElement('div');
    bubble.className = 'chat-bubble';
    bubble.textContent = message.content;
    element.appendChild(bubble);

    const meta = document.createElement('span');
    meta.className = 'chat-meta';
    meta.textContent = formatMeta(message);
    element.appendChild(meta);

    return { element, bubble, meta };
  }

  function renderAllMessages(scrollBehavior = 'auto') {
    threadEl.textContent = '';
    state.messageElements.clear();

    const messages = getActiveThreadMessages();
    state.messages = messages;

    const fragment = document.createDocumentFragment();
    messages.forEach((message) => {
      const { element, bubble, meta } = buildMessageElement(message);
      state.messageElements.set(message.id, { element, bubble, meta });
      fragment.appendChild(element);
    });

    threadEl.appendChild(fragment);
    renderThreadList();
    scrollToBottom(scrollBehavior);
    updateSendButton();
  }

  function formatMeta(message) {
    const label = message.role === 'user' ? '\u3042\u306A\u305F' : assistantProfile.name;
    const time = new Intl.DateTimeFormat('ja-JP', {
      hour: '2-digit',
      minute: '2-digit',
    }).format(message.createdAt || Date.now());
    return `${label}\u30FB${time}`;
  }

  function updateMessageBubble(messageId, content) {
    const { message } = findMessageById(messageId);
    if (!message) return;
    message.content = content;

    const entry = state.messageElements.get(messageId);
    if (entry) {
      entry.bubble.textContent = content;
    }
  }

  function setMessageStatus(messageId, status) {
    const entry = state.messageElements.get(messageId);
    if (entry) {
      entry.meta.textContent = status;
    }
  }

  function setTypingState(messageId, isTyping) {
    const entry = state.messageElements.get(messageId);
    if (entry) {
      entry.element.classList.toggle('is-typing', isTyping);
    }
  }

  function finalizeMessage(messageId, finalText) {
    updateMessageBubble(messageId, finalText);
    const { thread, message } = findMessageById(messageId);
    if (message) {
      message.createdAt = Date.now();
    }
    const entry = state.messageElements.get(messageId);
    if (entry) {
      entry.element.classList.remove('is-typing');
      entry.meta.textContent = message ? formatMeta(message) : `${assistantProfile.name}`;
    }
    if (thread) {
      thread.updatedAt = message?.createdAt || Date.now();
    }
    saveMessages();
    updateEmptyState();
    renderThreadList();
    if (thread && thread.id === state.activeThreadId) {
      scrollToBottom('smooth');
    }
  }

  function autoResizeTextArea() {
    textareaEl.style.height = 'auto';
    textareaEl.style.height = `${Math.min(textareaEl.scrollHeight, 180)}px`;
  }

  function updateSendButton() {
    const hasThread = Boolean(getActiveThread());
    const hasText = textareaEl.value.trim().length > 0;
    sendButtonEl.disabled = !hasThread || !hasText;
    const previouslyDisabled = textareaEl.disabled;
    textareaEl.disabled = !hasThread;
    if (!hasThread) {
      textareaEl.placeholder = composerNoThreadPlaceholder;
      textareaEl.setAttribute('aria-disabled', 'true');
      if (!previouslyDisabled) {
        textareaEl.value = '';
      }
      textareaEl.style.height = '';
    } else {
      textareaEl.placeholder = composerDefaultPlaceholder;
      textareaEl.removeAttribute('aria-disabled');
      autoResizeTextArea();
    }
  }

  function updateThreadControls() {
    if (!threadListEl) return;
    const deleteButtons = threadListEl.querySelectorAll('[data-action="delete-thread"]');
    deleteButtons.forEach((button) => {
      const threadId = button.dataset.threadId;
      const thread = threadId ? getThreadById(threadId) : null;
      button.disabled = !thread;
    });
  }

  function updateEmptyState() {
    const hasMessages = getActiveThreadMessages().length > 0;
    emptyStateEl.hidden = hasMessages;
    threadEl.classList.toggle('is-empty', !hasMessages);
    updateThreadControls();
  }

  function scrollToBottom(behavior = 'smooth') {
    window.requestAnimationFrame(() => {
      threadEl.scrollTo({
        top: threadEl.scrollHeight,
        behavior,
      });
    });
  }

  function runTypewriterAnimation(bubbleEl, fullText, onComplete) {
    const characters = Array.from(fullText);
    bubbleEl.textContent = '';
    let index = 0;

    const tick = () => {
      if (index >= characters.length) {
        if (typeof onComplete === 'function') {
          onComplete();
        }
        return;
      }

      bubbleEl.textContent += characters[index];
      index += 1;
      const previousChar = characters[index - 1] || '';
      const pause = /[\u3002\uFF01\uFF1F!?.]/.test(previousChar) ? 110 : 26;
      window.setTimeout(() => {
        window.requestAnimationFrame(tick);
      }, pause);
    };

    tick();
  }

  function pickAssistantReply(userContent) {
    const normalizedLower = userContent.toLowerCase();
    const normalized = userContent;

    if (normalized.includes('\u3042\u308A\u304C\u3068\u3046') || normalizedLower.includes('thanks')) {
      return '\u3069\u3046\u3044\u305F\u3057\u307E\u3057\u3066\u3002\u3044\u3064\u3067\u3082\u30B5\u30DD\u30FC\u30C8\u3057\u307E\u3059\u306D\u3002';
    }

    if (normalized.includes('\u6B21') || normalizedLower.includes('next')) {
      return '\u6B21\u306E\u30B9\u30C6\u30C3\u30D7\u3068\u3057\u3066\u30B9\u30EC\u30C3\u30C9\u4E00\u89A7\u306EUI\u3092\u6E96\u5099\u3057\u3066\u304A\u304F\u3068\u30B9\u30E0\u30FC\u30BA\u3067\u3059\u3002';
    }

    const index = Math.floor(Math.random() * assistantProfile.cannedReplies.length);
    return assistantProfile.cannedReplies[index];
  }

  function generateThreadId() {
    return `thread-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`;
  }

  function generateMessageId() {
    return `msg-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`;
  }

  function sanitizeMessages(rawMessages) {
    if (!Array.isArray(rawMessages)) return [];
    const sanitized = [];
    for (const entry of rawMessages) {
      if (!isValidMessage(entry)) continue;
      const normalized = {
        id: typeof entry.id === 'string' && entry.id.trim() ? entry.id.trim() : generateMessageId(),
        role: entry.role,
        content: entry.content,
        createdAt:
          typeof entry.createdAt === 'number' && Number.isFinite(entry.createdAt)
            ? entry.createdAt
            : Date.now(),
      };
      sanitized.push(normalized);
    }
    return sanitized.slice(-200);
  }

  function createDefaultThreadState(messages = []) {
    const sanitized = sanitizeMessages(messages);
    const now = Date.now();
    const initialCreatedAt = sanitized.length ? sanitized[0].createdAt : now;
    const initialUpdatedAt = sanitized.length ? sanitized[sanitized.length - 1].createdAt : now;
    return {
      threads: [
        {
          id: 'main',
          title: MAIN_THREAD_TITLE,
          createdAt: initialCreatedAt,
          updatedAt: initialUpdatedAt,
          messages: sanitized,
        },
      ],
      activeThreadId: 'main',
    };
  }

  function loadThreadState() {
    try {
      const raw = window.localStorage.getItem(STORAGE_KEY);
      if (!raw) {
        return createDefaultThreadState([]);
      }
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        return createDefaultThreadState(parsed);
      }
      if (typeof parsed !== 'object' || parsed === null) {
        return createDefaultThreadState([]);
      }

      const storedThreads = Array.isArray(parsed.threads) ? parsed.threads : [];
      const normalizedThreads = [];
      const seenIds = new Set();
      let autoTitleIndex = 1;

      for (const thread of storedThreads) {
        if (!thread || typeof thread !== 'object') continue;
        let id =
          typeof thread.id === 'string' && thread.id.trim() ? thread.id.trim() : generateThreadId();
        if (seenIds.has(id)) {
          id = generateThreadId();
        }
        seenIds.add(id);

        const messages = sanitizeMessages(thread.messages);
        const now = Date.now();
        const createdAt =
          typeof thread.createdAt === 'number' && Number.isFinite(thread.createdAt)
            ? thread.createdAt
            : messages[0]?.createdAt ?? now;
        const updatedAt =
          typeof thread.updatedAt === 'number' && Number.isFinite(thread.updatedAt)
            ? thread.updatedAt
            : messages[messages.length - 1]?.createdAt ?? createdAt;

        let title = '';
        if (id === 'main') {
          title = MAIN_THREAD_TITLE;
        } else if (typeof thread.title === 'string' && thread.title.trim()) {
          title = thread.title.trim();
        } else {
          title = `${NEW_THREAD_TITLE_BASE} ${autoTitleIndex}`;
          autoTitleIndex += 1;
        }

        normalizedThreads.push({
          id,
          title,
          createdAt,
          updatedAt,
          messages,
        });
      }

      if (normalizedThreads.length === 0 && storedThreads.length === 0) {
        return {
          threads: [],
          activeThreadId: null,
        };
      }

      if (normalizedThreads.length === 0) {
        return createDefaultThreadState([]);
      }

      const requestedActive =
        typeof parsed.activeThreadId === 'string' ? parsed.activeThreadId : null;
      const activeThreadId = normalizedThreads.some((thread) => thread.id === requestedActive)
        ? requestedActive
        : normalizedThreads[0]?.id ?? null;

      return {
        threads: normalizedThreads,
        activeThreadId,
      };
    } catch (error) {
      console.warn('Unable to load stored threads:', error);
      return createDefaultThreadState([]);
    }
  }

  function saveMessages() {
    try {
      const payload = JSON.stringify({
        version: THREAD_STORAGE_VERSION,
        activeThreadId: state.activeThreadId || null,
        threads: state.threads.map((thread) => ({
          id: thread.id,
          title: thread.id === 'main' ? MAIN_THREAD_TITLE : thread.title,
          createdAt: thread.createdAt,
          updatedAt: thread.updatedAt,
          messages: thread.messages.slice(-200).map((message) => ({
            id:
              typeof message.id === 'string' && message.id.trim()
                ? message.id.trim()
                : generateMessageId(),
            role: message.role,
            content: message.content,
            createdAt:
              typeof message.createdAt === 'number' && Number.isFinite(message.createdAt)
                ? message.createdAt
                : Date.now(),
          })),
        })),
      });
      window.localStorage.setItem(STORAGE_KEY, payload);
    } catch (error) {
      console.warn('Unable to save messages:', error);
    }
  }

  function getThreadById(threadId) {
    if (typeof threadId !== 'string') return null;
    return state.threads.find((thread) => thread.id === threadId) || null;
  }

  function getActiveThread() {
    const active =
      typeof state.activeThreadId === 'string' ? getThreadById(state.activeThreadId) : null;
    if (active) {
      return active;
    }
    const fallback = state.threads[0] || null;
    if (fallback && state.activeThreadId !== fallback.id) {
      state.activeThreadId = fallback.id;
    }
    return fallback;
  }

  function getActiveThreadMessages() {
    const thread = getActiveThread();
    return thread ? thread.messages : [];
  }

  function getNextThreadTitle() {
    const count = state.threads.filter((thread) => thread.id !== 'main').length + 1;
    return `${NEW_THREAD_TITLE_BASE} ${count}`;
  }

  function findMessageById(messageId) {
    if (typeof messageId !== 'string') {
      return { thread: null, message: null };
    }
    for (const thread of state.threads) {
      const message = thread.messages.find((item) => item.id === messageId);
      if (message) {
        return { thread, message };
      }
    }
    return { thread: null, message: null };
  }

  function setActiveThread(threadId, options = {}) {
    const thread = getThreadById(threadId);
    if (!thread || state.activeThreadId === thread.id) return;
    const { scrollBehavior = 'auto' } = options;
    state.activeThreadId = thread.id;
    state.messages = thread.messages;
    renderAllMessages(scrollBehavior);
    updateEmptyState();
    saveMessages();
  }

  function loadConfig() {
    try {
      const raw = window.localStorage.getItem(CONFIG_KEY);
      if (!raw) return { ...DEFAULT_CONFIG };
      const parsed = JSON.parse(raw);
      if (typeof parsed !== 'object' || parsed === null) return { ...DEFAULT_CONFIG };
      return {
        assistantName:
          typeof parsed.assistantName === 'string' && parsed.assistantName.trim()
            ? parsed.assistantName.trim()
            : DEFAULT_CONFIG.assistantName,
        assistantStatus:
          typeof parsed.assistantStatus === 'string' && parsed.assistantStatus.trim()
            ? parsed.assistantStatus.trim()
            : DEFAULT_CONFIG.assistantStatus,
        apiKey: typeof parsed.apiKey === 'string' ? parsed.apiKey : DEFAULT_CONFIG.apiKey,
        systemPrompt:
          typeof parsed.systemPrompt === 'string' && parsed.systemPrompt.trim()
            ? parsed.systemPrompt
            : DEFAULT_CONFIG.systemPrompt,
        model:
          typeof parsed.model === 'string' && SUPPORTED_MODELS.includes(parsed.model.trim())
            ? parsed.model.trim()
            : DEFAULT_CONFIG.model,
        avatarUrl:
          typeof parsed.avatarUrl === 'string'
            ? parsed.avatarUrl
            : DEFAULT_CONFIG.avatarUrl,
        avatarData:
          typeof parsed.avatarData === 'string'
            ? parsed.avatarData
            : DEFAULT_CONFIG.avatarData,
      };
    } catch (error) {
      console.warn('Unable to load config:', error);
      return { ...DEFAULT_CONFIG };
    }
  }

  function saveConfig() {
    try {
      const payload = JSON.stringify({
        assistantName: state.config.assistantName,
        assistantStatus: state.config.assistantStatus,
        apiKey: state.config.apiKey,
        systemPrompt: state.config.systemPrompt,
        model: state.config.model,
        avatarUrl: state.config.avatarUrl,
        avatarData: state.config.avatarData,
      });
      window.localStorage.setItem(CONFIG_KEY, payload);
    } catch (error) {
      console.warn('Unable to save config:', error);
    }
  }

  function clearMessages() {
    cancelPendingAssistant();
    const thread = getActiveThread();
    if (!thread) return;
    thread.messages = [];
    thread.updatedAt = Date.now();
    state.messages = thread.messages;
    saveMessages();
    renderAllMessages();
    updateEmptyState();
    if (!textareaEl.disabled) {
      textareaEl.focus();
    }
  }

  function isValidMessage(message) {
    return (
      message &&
      (message.role === 'user' || message.role === 'assistant') &&
      typeof message.content === 'string'
    );
  }

  function applyConfigToUI() {
    profileNameEl.textContent = state.config.assistantName || DEFAULT_CONFIG.assistantName;
    profileStatusEl.textContent = state.config.assistantStatus || DEFAULT_CONFIG.assistantStatus;
    assistantProfile.name = state.config.assistantName || DEFAULT_CONFIG.assistantName;
    updateAvatarDisplay();
  }

  function updateAvatarDisplay(previewSource) {
    if (!avatarEl || !avatarInitialEl) return;
    const nameSource =
      (state.config.assistantName || DEFAULT_CONFIG.assistantName || '').trim() || 'A';
    const initialChar = Array.from(nameSource)[0] || 'A';
    avatarInitialEl.textContent = initialChar;

    const usingPreview = previewSource !== undefined;
    const dataSource = usingPreview
      ? ((previewSource || '').toString().trim())
      : (state.config.avatarData || '').trim();
    const urlSource = usingPreview ? '' : (state.config.avatarUrl || '').trim();

    const applyInitial = () => {
      if (avatarImageEl) {
        avatarImageEl.hidden = true;
        avatarImageEl.removeAttribute('src');
      }
      delete avatarEl.dataset.hasImage;
    };

    const applyImage = (source) => {
      if (!avatarImageEl) {
        avatarEl.dataset.hasImage = 'true';
        return;
      }
      const handleLoad = () => {
        avatarImageEl.hidden = false;
        avatarEl.dataset.hasImage = 'true';
      };
      const handleError = () => {
        avatarImageEl.hidden = true;
        avatarImageEl.removeAttribute('src');
        delete avatarEl.dataset.hasImage;
      };
      avatarImageEl.onload = handleLoad;
      avatarImageEl.onerror = handleError;
      avatarImageEl.src = source;
      if (avatarImageEl.complete && avatarImageEl.naturalWidth > 0) {
        handleLoad();
      }
    };

    if (dataSource) {
      applyImage(dataSource);
      return;
    }

    if (urlSource) {
      applyImage(urlSource);
      return;
    }

    applyInitial();
  }

  function updateAvatarStatus(message) {
    if (!avatarStatusEl) return;
    avatarStatusEl.textContent = message;
  }

  function applyDefaultAvatarStatus() {
    const hasUpload = !!state.draftAvatarData;
    const hasUrl = !!(state.config.avatarUrl || '').trim();
    if (hasUpload) {
      updateAvatarStatus(AVATAR_STATUS_TEXT.inUse);
    } else if (hasUrl) {
      updateAvatarStatus(AVATAR_STATUS_TEXT.usingUrl);
    } else {
      updateAvatarStatus(AVATAR_STATUS_TEXT.empty);
    }
  }

  function resetAvatarDraft() {
    state.avatarReadToken += 1;
    state.draftAvatarData = state.config.avatarData || '';
    if (avatarFileInput instanceof HTMLInputElement) {
      avatarFileInput.value = '';
    }
    applyDefaultAvatarStatus();
    updateAvatarDisplay();
  }

  async function handleAvatarFileChange(event) {
    const input = event.target;
    if (!(input instanceof HTMLInputElement)) return;
    const file = input.files && input.files[0];
    if (!file) {
      return;
    }
    if (!file.type.startsWith('image/')) {
      updateAvatarStatus(AVATAR_STATUS_TEXT.chooseImage);
      input.value = '';
      return;
    }
    if (file.size > MAX_AVATAR_FILE_SIZE) {
      updateAvatarStatus(AVATAR_STATUS_TEXT.sizeLimit);
      input.value = '';
      return;
    }
    const token = ++state.avatarReadToken;
    updateAvatarStatus(AVATAR_STATUS_TEXT.processing);
    try {
      const processed = await prepareAvatarDataUrl(file);
      if (state.avatarReadToken !== token) {
        return;
      }
      state.draftAvatarData = processed;
      updateAvatarStatus(AVATAR_STATUS_TEXT.pending);
      updateAvatarDisplay(state.draftAvatarData);
    } catch (error) {
      if (state.avatarReadToken !== token) {
        return;
      }
      console.warn('Unable to process avatar file:', error);
      updateAvatarStatus(AVATAR_STATUS_TEXT.readError);
      input.value = '';
      state.draftAvatarData = state.config.avatarData || '';
      updateAvatarDisplay();
    }
  }

  function clearAvatarSelection(event) {
    if (event) event.preventDefault();
    state.avatarReadToken += 1;
    state.draftAvatarData = '';
    if (avatarFileInput instanceof HTMLInputElement) {
      avatarFileInput.value = '';
    }
    updateAvatarStatus(AVATAR_STATUS_TEXT.cleared);
    updateAvatarDisplay('');
  }

  async function prepareAvatarDataUrl(file) {
    const baseDataUrl = await readFileAsDataUrl(file);
    if (!supportsCanvas()) {
      return baseDataUrl;
    }
    try {
      const image = await loadImageFromSource(baseDataUrl);
      return optimizeAvatarDataUrl(image, baseDataUrl, file.type || '');
    } catch (error) {
      console.warn('Unable to optimise avatar image:', error);
      return baseDataUrl;
    }
  }

  function readFileAsDataUrl(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        if (typeof reader.result === 'string') {
          resolve(reader.result);
        } else {
          reject(new Error('Unexpected reader result'));
        }
      };
      reader.onerror = () => {
        reject(reader.error || new Error('Unable to read file'));
      };
      reader.readAsDataURL(file);
    });
  }

  function supportsCanvas() {
    if (typeof document === 'undefined' || typeof document.createElement !== 'function') {
      return false;
    }
    const canvas = document.createElement('canvas');
    return !!canvas && typeof canvas.getContext === 'function';
  }

  function loadImageFromSource(source) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error('Failed to load image'));
      image.src = source;
    });
  }

  function optimizeAvatarDataUrl(image, fallbackDataUrl, originalType) {
    let width = image.naturalWidth || image.width || 0;
    let height = image.naturalHeight || image.height || 0;
    if (!width || !height) {
      return fallbackDataUrl;
    }

    const maxDimension = Math.max(width, height);
    if (maxDimension > MAX_AVATAR_DIMENSION) {
      const scale = MAX_AVATAR_DIMENSION / maxDimension;
      width = Math.max(1, Math.round(width * scale));
      height = Math.max(1, Math.round(height * scale));
    }

    const candidates = getAvatarExportCandidates(originalType, image);
    let currentWidth = width;
    let currentHeight = height;

    while (currentWidth >= MIN_AVATAR_DIMENSION && currentHeight >= MIN_AVATAR_DIMENSION) {
      const encodings = tryEncodeAvatar(image, currentWidth, currentHeight, candidates);
      const acceptable = encodings.find((entry) => entry.data.length <= MAX_AVATAR_DATA_LENGTH);
      if (acceptable) {
        return acceptable.data;
      }
      if (currentWidth === MIN_AVATAR_DIMENSION && currentHeight === MIN_AVATAR_DIMENSION) {
        break;
      }
      currentWidth = Math.max(MIN_AVATAR_DIMENSION, Math.floor(currentWidth * 0.85));
      currentHeight = Math.max(MIN_AVATAR_DIMENSION, Math.floor(currentHeight * 0.85));
    }

    const fallbackEncodings = tryEncodeAvatar(image, MIN_AVATAR_DIMENSION, MIN_AVATAR_DIMENSION, candidates);
    if (fallbackEncodings.length) {
      return fallbackEncodings.reduce((best, entry) => (entry.data.length < best.data.length ? entry : best)).data;
    }
    return fallbackDataUrl;
  }

  function getAvatarExportCandidates(originalType, image) {
    const lower = (originalType || '').toLowerCase();
    const allowAlpha = lower.includes('png') || lower.includes('webp') || lower.includes('svg');
    const needsAlpha = allowAlpha && imageHasAlpha(image);
    const candidates = needsAlpha
      ? [
          { type: 'image/webp', quality: 0.86 },
          { type: 'image/png' },
        ]
      : [
          { type: 'image/webp', quality: 0.82 },
          { type: 'image/webp', quality: 0.7 },
          { type: 'image/jpeg', quality: 0.82 },
          { type: 'image/jpeg', quality: 0.72 },
        ];
    if (!candidates.some((candidate) => candidate.type === 'image/png')) {
      candidates.push({ type: 'image/png' });
    }
    return candidates;
  }

  function imageHasAlpha(image) {
    const width = image.naturalWidth || image.width || 0;
    const height = image.naturalHeight || image.height || 0;
    if (!width || !height) {
      return false;
    }
    const sampleWidth = Math.min(width, 64);
    const sampleHeight = Math.min(height, 64);
    const canvas = document.createElement('canvas');
    canvas.width = sampleWidth;
    canvas.height = sampleHeight;
    const context = canvas.getContext('2d', { willReadFrequently: true });
    if (!context) {
      return false;
    }
    context.drawImage(image, 0, 0, sampleWidth, sampleHeight);
    try {
      const { data } = context.getImageData(0, 0, sampleWidth, sampleHeight);
      for (let index = 3; index < data.length; index += 4) {
        if (data[index] < 255) {
          return true;
        }
      }
    } catch (error) {
      if (!(error && error.name === 'SecurityError')) {
        console.warn('Unable to inspect avatar transparency:', error);
      }
    }
    return false;
  }

  function tryEncodeAvatar(image, width, height, candidates) {
    const results = [];
    candidates.forEach((candidate) => {
      try {
        const data = drawImageToDataUrl(image, width, height, candidate.type, candidate.quality);
        if (data) {
          results.push({ ...candidate, data });
        }
      } catch (error) {
        // Ignore encoding failures for specific formats; fallbacks will handle it.
      }
    });
    if (!results.length) {
      try {
        const fallbackData = drawImageToDataUrl(image, width, height, 'image/png');
        if (fallbackData) {
          results.push({ type: 'image/png', data: fallbackData });
        }
      } catch (error) {
        console.warn('Avatar fallback encoding failed:', error);
      }
    }
    return results;
  }

  function drawImageToDataUrl(image, width, height, type, quality) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext('2d');
    if (!context) {
      throw new Error('Canvas context unavailable');
    }
    context.drawImage(image, 0, 0, width, height);
    if (typeof quality === 'number') {
      return canvas.toDataURL(type, quality);
    }
    return canvas.toDataURL(type);
  }

  function populateSettingsForm() {
    if (!settingsForm) return;
    const { assistantName, assistantStatus, apiKey, systemPrompt, model, avatarUrl } = state.config;
    const nameInput = settingsForm.elements.namedItem('assistantName');
    const statusInput = settingsForm.elements.namedItem('assistantStatus');
    const apiKeyInput = settingsForm.elements.namedItem('apiKey');
    const systemPromptInput = settingsForm.elements.namedItem('systemPrompt');
    const modelInput = settingsForm.elements.namedItem('model');
    const avatarInput = settingsForm.elements.namedItem('avatarUrl');

    if (nameInput) nameInput.value = assistantName || '';
    if (statusInput) statusInput.value = assistantStatus || '';
    if (apiKeyInput) apiKeyInput.value = apiKey || '';
    if (systemPromptInput) systemPromptInput.value = systemPrompt || DEFAULT_SYSTEM_PROMPT;
    if (modelInput) {
      const currentModel = SUPPORTED_MODELS.includes(model) ? model : DEFAULT_CONFIG.model;
      modelInput.value = currentModel;
    }
    if (avatarInput) avatarInput.value = avatarUrl || '';
    resetAvatarDraft();
  }

  function handleSettingsSubmit(event) {
    event.preventDefault();
    if (!settingsForm) return;
    const formData = new FormData(settingsForm);
    state.config.assistantName =
      (formData.get('assistantName') || '').toString().trim() || DEFAULT_CONFIG.assistantName;
    state.config.assistantStatus =
      (formData.get('assistantStatus') || '').toString().trim() || DEFAULT_CONFIG.assistantStatus;
    state.config.apiKey = (formData.get('apiKey') || '').toString().trim();
    state.config.systemPrompt =
      (formData.get('systemPrompt') || '').toString().trim() || DEFAULT_SYSTEM_PROMPT;
    const selectedModel = (formData.get('model') || '').toString().trim();
    state.config.model = SUPPORTED_MODELS.includes(selectedModel)
      ? selectedModel
      : DEFAULT_CONFIG.model;
    state.config.avatarUrl = (formData.get('avatarUrl') || '').toString().trim();
    state.config.avatarData = state.draftAvatarData || '';

    applyConfigToUI();
    saveConfig();
    closeSettings();
  }

  function renderThreadList() {
    if (!threadListEl) return;
    threadListEl.textContent = '';

    state.threads.forEach((thread, index) => {
      const threadItem = document.createElement('li');
      threadItem.className = 'thread-list-entry';

      const button = document.createElement('button');
      button.type = 'button';
      const isActive = state.activeThreadId
        ? thread.id === state.activeThreadId
        : index === 0;
      button.className = `thread-item${isActive ? ' is-active' : ''}`;
      button.dataset.threadId = thread.id;

      const title = document.createElement('div');
      title.className = 'thread-title';
      title.textContent = thread.title || MAIN_THREAD_TITLE;
      button.appendChild(title);

      const preview = document.createElement('div');
      preview.className = 'thread-preview';
      preview.textContent = formatThreadPreview(thread.messages);
      button.appendChild(preview);

      const deleteButton = document.createElement('button');
      deleteButton.type = 'button';
      deleteButton.className = 'thread-item-delete';
      deleteButton.dataset.action = 'delete-thread';
      deleteButton.dataset.threadId = thread.id;
      deleteButton.setAttribute('aria-label', '\u30B9\u30EC\u30C3\u30C9\u3092\u524A\u9664\u3059\u308B');
      deleteButton.innerHTML =
        '<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M6 6 18 18M6 18 18 6" vector-effect="non-scaling-stroke" /></svg>';

      threadItem.appendChild(button);
      threadItem.appendChild(deleteButton);
      threadListEl.appendChild(threadItem);
    });

    if (threadEmptyEl) {
      if (state.threads.length === 0) {
        threadEmptyEl.hidden = false;
        threadEmptyEl.textContent = '\u307E\u3060\u30B9\u30EC\u30C3\u30C9\u304C\u3042\u308A\u307E\u305B\u3093\u3002\u300C\u65B0\u898F\u30B9\u30EC\u30C3\u30C9\u300D\u3092\u62BC\u3057\u3066\u4F5C\u6210\u3057\u307E\u3057\u3087\u3046\u3002';
      } else {
        threadEmptyEl.hidden = true;
      }
    }
    updateThreadControls();
  }

  function formatThreadPreview(messages) {
    if (!messages.length) {
      return '\u307E\u3060\u30E1\u30C3\u30BB\u30FC\u30B8\u304C\u3042\u308A\u307E\u305B\u3093\u3002';
    }
    const lastMessage = messages[messages.length - 1].content || '';
    const normalized = lastMessage.replace(/\s+/g, ' ').trim();
    return normalized.length > 36 ? `${normalized.slice(0, 36)}\u2026` : normalized || '\u30E1\u30C3\u30BB\u30FC\u30B8';
  }

  function handleCreateThread() {
    const now = Date.now();
    const id = generateThreadId();
    const title = getNextThreadTitle();
    const newThread = {
      id,
      title,
      createdAt: now,
      updatedAt: now,
      messages: [],
    };
    state.threads.push(newThread);
    setActiveThread(newThread.id, { scrollBehavior: 'auto' });
    closeDrawer();
    if (!textareaEl.disabled) {
      textareaEl.focus();
    }
  }

  function handleDeleteThread(threadId) {
    if (typeof threadId !== 'string') return;
    const targetThread = getThreadById(threadId);
    if (!targetThread) return;

    const confirmed = window.confirm(
      '\u3053\u306E\u30B9\u30EC\u30C3\u30C9\u3092\u524A\u9664\u3059\u308B\u3068\u3001\u4F1A\u8A71\u5C65\u6B74\u306F\u5143\u306B\u623B\u305B\u307E\u305B\u3093\u3002\u524A\u9664\u3057\u307E\u3059\u304B\uFF1F'
    );
    if (!confirmed) return;

    if (state.pendingAssistant?.threadId === threadId) {
      cancelPendingAssistant();
    }

    const index = state.threads.findIndex((thread) => thread.id === threadId);
    if (index === -1) return;
    state.threads.splice(index, 1);

    if (state.activeThreadId === threadId) {
      const fallbackThread =
        state.threads[index] || state.threads[index - 1] || state.threads[0] || null;
      state.activeThreadId = fallbackThread ? fallbackThread.id : null;
    }

    state.messageElements.clear();
    state.messages = getActiveThreadMessages();
    saveMessages();
    renderAllMessages();
    updateEmptyState();
    if (state.activeThreadId && !textareaEl.disabled) {
      textareaEl.focus();
    } else {
      textareaEl.value = '';
      updateSendButton();
    }
  }

  function openDrawer() {
    if (!drawerLayer || !drawerEl || !drawerToggle) return;
    if (app.dataset.chatOpen === 'true') return;
    state.lastFocused.drawer = document.activeElement;
    app.dataset.chatOpen = 'true';
    drawerToggle.setAttribute('aria-expanded', 'true');
    drawerLayer.classList.add('is-open');
    drawerBackdrop?.setAttribute('aria-hidden', 'false');
    drawerEl.setAttribute('aria-hidden', 'false');
    focusFirstElement(drawerEl);
    activateFocusTrap('drawer', drawerEl);
  }

  function closeDrawer() {
    if (!drawerLayer || !drawerEl || !drawerToggle) return;
    if (app.dataset.chatOpen !== 'true') return;
    app.dataset.chatOpen = 'false';
    drawerToggle.setAttribute('aria-expanded', 'false');
    drawerLayer.classList.remove('is-open');
    drawerBackdrop?.setAttribute('aria-hidden', 'true');
    drawerEl.setAttribute('aria-hidden', 'true');
    deactivateFocusTrap('drawer', drawerEl);
    if (state.lastFocused.drawer instanceof HTMLElement) {
      state.lastFocused.drawer.focus();
    }
    state.lastFocused.drawer = null;
  }

  function openSettings() {
    if (!settingsLayer || !settingsModal || !settingsToggle) return;
    if (app.dataset.settingsOpen === 'true') return;
    state.lastFocused.settings = document.activeElement;
    populateSettingsForm();
    app.dataset.settingsOpen = 'true';
    settingsToggle.setAttribute('aria-expanded', 'true');
    settingsLayer.classList.add('is-open');
    settingsBackdrop?.setAttribute('aria-hidden', 'false');
    settingsModal.setAttribute('aria-hidden', 'false');
    focusFirstElement(settingsModal);
    activateFocusTrap('settings', settingsModal);
  }

  function closeSettings() {
    if (!settingsLayer || !settingsModal || !settingsToggle) return;
    if (app.dataset.settingsOpen !== 'true') return;
    app.dataset.settingsOpen = 'false';
    settingsToggle.setAttribute('aria-expanded', 'false');
    settingsLayer.classList.remove('is-open');
    settingsBackdrop?.setAttribute('aria-hidden', 'true');
    settingsModal.setAttribute('aria-hidden', 'true');
    deactivateFocusTrap('settings', settingsModal);
    if (state.lastFocused.settings instanceof HTMLElement) {
      state.lastFocused.settings.focus();
    }
    state.lastFocused.settings = null;
    resetAvatarDraft();
  }

  function handleGlobalKeydown(event) {
    if (event.key === 'Escape') {
      if (app.dataset.settingsOpen === 'true') {
        closeSettings();
        event.preventDefault();
        return;
      }
      if (app.dataset.chatOpen === 'true') {
        closeDrawer();
        event.preventDefault();
      }
    }
  }

  function focusFirstElement(root) {
    const focusables = getFocusableElements(root);
    if (focusables.length > 0) {
      focusables[0].focus();
    } else {
      root.focus();
    }
  }

  function activateFocusTrap(key, root) {
    const handler = (event) => {
      if (event.key !== 'Tab') return;
      const focusables = getFocusableElements(root);
      if (!focusables.length) {
        event.preventDefault();
        root.focus();
        return;
      }

      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      const active = document.activeElement;
      const isShift = event.shiftKey;

      if (isShift && active === first) {
        event.preventDefault();
        last.focus();
      } else if (!isShift && active === last) {
        event.preventDefault();
        first.focus();
      }
    };

    root.addEventListener('keydown', handler);
    state.focusTrapHandlers[key] = handler;
  }

  function deactivateFocusTrap(key, root) {
    const handler = state.focusTrapHandlers[key];
    if (handler) {
      root.removeEventListener('keydown', handler);
      state.focusTrapHandlers[key] = null;
    }
  }

  function getFocusableElements(root) {
    if (!root) return [];
    return Array.from(
      root.querySelectorAll(
        'button, [href], input, textarea, select, [tabindex]:not([tabindex="-1"])'
      )
    ).filter((element) => !element.hasAttribute('disabled') && element.getAttribute('aria-hidden') !== 'true');
  }

  function exposeFreshchatApi() {
    const api = {
      setApiKey(nextKey) {
        if (typeof nextKey !== 'string') return;
        state.config.apiKey = nextKey.trim();
        saveConfig();
      },
      getApiKey() {
        return state.config.apiKey || '';
      },
      clearHistory() {
        clearMessages();
      },
      getHistory() {
        return [...getActiveThreadMessages()];
      },
      setAssistantProfile({ name, status, systemPrompt, model, avatarUrl, avatarData }) {
        if (typeof name === 'string' && name.trim()) {
          state.config.assistantName = name.trim();
        }
        if (typeof status === 'string' && status.trim()) {
          state.config.assistantStatus = status.trim();
        }
        if (typeof systemPrompt === 'string' && systemPrompt.trim()) {
          state.config.systemPrompt = systemPrompt.trim();
        }
        if (typeof model === 'string' && model.trim()) {
          const trimmedModel = model.trim();
          if (SUPPORTED_MODELS.includes(trimmedModel)) {
            state.config.model = trimmedModel;
          }
        }
        if (typeof avatarUrl === 'string') {
          state.config.avatarUrl = avatarUrl.trim();
        }
        if (typeof avatarData === 'string') {
          state.config.avatarData = avatarData;
        }
        resetAvatarDraft();
        applyConfigToUI();
        saveConfig();
      },
      setModel(nextModel) {
        if (typeof nextModel !== 'string' || !nextModel.trim()) return;
        const trimmedModel = nextModel.trim();
        if (!SUPPORTED_MODELS.includes(trimmedModel)) return;
        state.config.model = trimmedModel;
        saveConfig();
      },
    };

    window.freshchat = Object.assign(window.freshchat || {}, api);
  }

  init();
})();
</file>

</files>
